<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>Free your mind with JDBI</title>

  <meta name="description" content="Using explicit SQL mappers in Enterprise Applications">
  <meta name="author" content="Maciej Małecki">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>reveal.js</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/night.css" id="theme">
  <link rel="stylesheet" href="css/custom.css">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section data-background-image="img/super-mind.jpg" data-background-opacity="0.5">
      <h3>Free your mind with JDBI</h3>
      <p>using explicit SQL mappers...</p>
      <p>...in enterprise applications</p>
      <p style="font-size: 20px; margin-top: 8em; text-align: right">Maciej Małecki, Architecture Community, Capgemini
        2021.</p>
    </section>

    <!-- ----------------------------------------
               Introduction
    ----------------------------------------- -->
    <section data-background-image="img/clean-architecture.jpeg">
    </section>
    <section data-auto-animate data-auto-animate-easing="cubic-bezier(0.770, 0.000, 0.175, 1.000)">
      <h2 data-id="title">Why?</h2>
      <div class="r-hstack">
        <img data-id="img" class="pane" src="img/hibernate-logo.png" alt="Hibernate Logo" style="margin: 0 0.8em 0 0.8em;">
        <div class="r-vstack">
          <div class="pane bcol0">1: SQL-PoJo binding</div>
          <div class="pane bcol1">2: SQL dialect agnostic</div>
          <div class="pane bcol2">3: transparent persistence</div>
        </div>
      </div>
    </section>
    <section data-auto-animate data-auto-animate-easing="cubic-bezier(0.770, 0.000, 0.175, 1.000)">
      <h2 data-id="title">Transparent persistence</h2>
      <div class="r-hstack">
        <div class="r-vstack fragment">
          <div class="pane bcol0">change detection</div>
          <div class="pane bcol3">associations</div>
          <div class="r-hstack">
            <div class="pane bcol1">n+1</div>
            <div class="pane bcol2">proxies</div>
          </div>
          <div class="pane bcol4">no boundaries</div>
        </div>
        <img data-id="img" class="pane" src="img/hibernate-logo.png" alt="Hibernate Logo" style="margin: 0 0.8em 0 0.8em;">
        <div class="r-vstack fragment">
          <div class="pane bcol1">fetching strategies</div>
          <div class="pane bcol2">entity graphs</div>
          <div class="pane bcol3">stateful session</div>
        </div>
      </div>
      <p class="fragment emph">&#8687;&#8687;&#8687; hidden complexity &#8687;&#8687;&#8687;</p>
    </section>
    <section data-auto-animate data-auto-animate-easing="cubic-bezier(0.770, 0.000, 0.175, 1.000)">
      <h3 data-id="title">What are the SQL mappers?</h3>
      <div class="r-vstack">
        <div class="r-hstack">
          <img class="pane hsmall" src="img/jooq-logo-white.png" alt="JOOQ">
          <img data-id="jdbi-img" class="pane hsmall" src="img/jdbi.png" alt="JDBI">
          <img class="pane hsmall" src="img/spring-jdbc-logo.jpg" alt="spring">
        </div>
        <div class="r-hstack">
          <img class="pane" src="img/r2dbc.png" alt="r2dbc">
          <img class="pane hsmall" src="img/jdbc.png" alt="JDBC">
        </div>
      </div>
    </section>
    <section data-auto-animate data-auto-animate-easing="cubic-bezier(0.770, 0.000, 0.175, 1.000)">
      <h3 data-id="title">When should I prefer a mapper?</h3>
      <div class="r-hstack">
        <img data-id="jdbi-img" class="pane hmed" src="img/jdbi.png" alt="JDBI">
        <div>
          <ul>
            <li>"read-only" app - dump data on screen</li>
            <li>"write-only" app - data importers & updaters</li>
            <li>CQRS</li>
            <li>event sourcing</li>
            <li>hexagonal</li>
            <li>"small" apps of any kind</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- ----------------------------------------
               JDBI Basics
    ----------------------------------------- -->
    <section data-auto-animate>
      <div class="r-hstack">
        <div class="r-vstack">
          <div class="pane bcol0">SQL &#8621; POJO mapper</div>
          <div class="pane bcol1">fluent and declarative API</div>
          <div class="pane bcol2">wraps around JDBC</div>
          <div class="pane bcol3">native SQL, no limits</div>
          <div class="pane bcol4">no fake persistence</div>
        </div>
        <img data-id="jdbi-img" class="pane hmed" src="img/jdbi.png" alt="JDBI">
      </div>
    </section>
    <section>
      <h3>JDBI</h3>
      <p>example config in Spring/Kotlin</p>
      <pre><code class="hljs" data-trim data-line-numbers="|3-5|13|14-17|21"><script type="text/template">
        @Configuration
        class JdbiConfiguration {
          @Bean
          @ConfigurationProperties(prefix = "spring.datasource")
          fun dataSource() = DriverManagerDataSource()

          @Bean
          fun dataSourceTransactionManager() =
            DataSourceTransactionManager(dataSource())

          @Bean
          fun jdbi(): Jdbi {
            val jdbi = Jdbi.create(dataSource())
              .installPlugin(SqlObjectPlugin())
              .installPlugin(PostgresPlugin())
              .installPlugin(KotlinPlugin())
              .installPlugin(KotlinSqlObjectPlugin())

              jdbi.getConfig(SqlStatements::class.java)
                .isUnusedBindingAllowed = true
              return jdbi
          }
        }
      </script></code></pre>
    </section>
    <section>
      <h3>Simple SELECT</h3>
      <pre><code class="hljs" data-trim data-line-numbers="|1|2|3|4|5 "><script type="text/template">
      Jdbi jdbi = Jdbi.create("jdbc:h2:mem:test");
      List<User> users = jdbi.withHandle(handle -> {
        return handle.createQuery("SELECT id, name FROM users ORDER BY name")
                 .mapToBean(User.class)
                 .list();
      }
      </script></code></pre>
    </section>
    <section>
      <h3>Simple INSERT</h3>
      <pre><code class="hljs" data-trim data-line-numbers="|1-2|3-4|5 "><script type="text/template">
        int count = handle.createUpdate(
                      "INSERT INTO users(id, name) VALUES (:id, :name)")
                      .bind("id", 5)
                      .bind("name", "foo")
                      .execute();
      </script></code></pre>
    </section>
    <section>
      <h3>or bean mapped INSERT</h3>
      <pre><code class="hljs" data-trim data-line-numbers="|1-2|3|4 "><script type="text/template">
        int count = handle.createUpdate(
                      "INSERT INTO users(id, name) VALUES (:id, :name)")
                      .bindBean(new User(5, "foo")
                      .execute();
      </script></code></pre>
    </section>

    <!-- ----------------------------------------
               SQL Objects
    ----------------------------------------- -->
    <section>
      <h3>SQL Object (kotlin)</h3>
      <pre><code class="hljs" data-trim data-line-numbers="|1|2-3|5-6|9-11"><script type="text/template">
      interface ManufacturerDao {
        @SqlQuery("SELECT id, name FROM Manufacturers ORDER BY name")
        fun selectAll(): List<ManufacturerRec>

        @SqlQuery("SELECT id, name FROM Manufacturers WHERE id=?")
        fun selectById(id: Long): ManufacturerRec?
      }

      data class ManufacturerRec(
          val id: Long,
          val name: String)
      </script></code></pre>
    </section>
    <section>
      <h3>SQL Objects</h3>
      <pre><code class="hljs" data-trim data-line-numbers="|2-11|4|5-10|13-22"><script type="text/template">
      class ManufacturerCrudJdbiRepository(private val db: Jdbi) : ManufacturerCrudRepository {
        override fun findAll(): List<Manufacturer> =
          db.withHandle<List<Manufacturer>, RuntimeException> { handle ->
            val dao = handle.attach(ManufacturerDao::class.java)
            dao.selectAll().map {
                Manufacturer(
                    id = ManufacturerAppId(it.id),
                    name = it.name
                )
            }
          }

        override fun findById(id: ManufacturerId): Manufacturer? =
          db.withHandle<Manufacturer?, RuntimeException> { handle ->
            val dao = handle.attach(ManufacturerDao::class.java)
            dao.selectById(id.asAppId().id)?.let { rec ->
                Manufacturer(
                    id = ManufacturerAppId(rec.id),
                    name = rec.name
                )
            }
          }
      }
      </script></code></pre>
    </section>
    <section>
      <p>Insert/update/delete + count</p>
      <p>Insert + keygen</p>
    </section>
    <section>
      <h3>Find by criteria (Devonfw style)</h3>
      <pre><code class="hljs" data-trim data-line-numbers="|9-13|16-17|19-23"><script type="text/template">
      @SqlQuery("""
        SELECT
          items.name AS name, item_class_name, item_class_version,
          manufacturer_id, manufacturers.name AS manufacturer_name,
          manufacturers_code
        FROM Items
        LEFT OUTER JOIN Manufacturers ON items.manufacturer_id = manufacturers.id
        WHERE
          1=1
          <if(name)>AND items.name LIKE :name<endif>
          <if(manufacturersCode)>AND manufacturers_code LIKE :manufacturersCode<endif>
          <if(manufacturerIds)>AND manufacturer_id IN (<manufacturerIds>)<endif>
          <if(itemClassIds)>AND item_class_name IN (<itemClassIds>)<endif>
        ORDER BY name"""
      )
      @DefineNamedBindings
      @UseStringTemplateEngine
      fun selectItemsByCriteria(
        @BindBean criteria: ItemSearchJdbiCriteria,
        @BindList("manufacturerIds", onEmpty = BindList.EmptyHandling.NULL_VALUE)
          manufacturerIds: List<Long>?,
        @BindList("itemClassIds", onEmpty = BindList.EmptyHandling.NULL_VALUE)
          itemClassIds: List<String>?
      ): List<ItemWithManufacturerRec>
			</script></code></pre>
    </section>

    <!-- ----------------------------------------
                   Advanced topics:
          persistence of entities and aggregates
    ----------------------------------------- -->
    <section>
      <p>Select with complex aggregate</p>
    </section>
    <section>
      <p>Fast lane queries C*Q*RS</p>
    </section>
    <section>
      <p>Update & optimistic locking</p>
    </section>
    <section>
      <p>Update & command pattern</p>
    </section>
    <section data-auto-animate>
      <h3 data-id="code-title">DAO for Item Stock aggregate</h3>
      <pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|2-5|7-12|34-38|21-31|40-47"><script type="text/template">
      interface ItemStockDao {
        @SqlUpdate("""
          INSERT INTO Item_Stock (item_name, serial, amount)
          VALUES (:id.itemId.id, :id.serial+1, :amount)""")
        fun insertItemStock(id: ItemStockAppId, amount: BigDecimal): Int

        @SqlQuery("""
          SELECT item_name, SUM(amount) AS amount, MAX(serial) AS serial
          FROM Item_Stock
          WHERE item_name=:id.id
          GROUP BY item_name""")
        fun selectStockAmount(id: ItemAppId): ItemStockRec?

        @SqlQuery("""
          SELECT item_name, SUM(amount) AS amount, MAX(serial) AS serial
          FROM Item_Stock
          WHERE item_name IN (<ids>)
          GROUP BY item_name""")
        fun selectStockAmounts(@BindList("ids") ids: Array<String>): List<ItemStockRec>

        @SqlQuery("""
          SELECT
            item_name, MAX(serial) AS serial, manufacturers_code, code AS unit_code,
            u.name AS unit_name, SUM(amount) AS amount
          FROM Item_Stock its
          JOIN Items i ON its.item_name = i.name
          JOIN Item_classes ic ON i.item_class_name = ic.name AND i.item_class_version = ic.version
          JOIN Units u ON ic.unit = u.code
          GROUP BY item_name, manufacturers_code, code, u.name
          ORDER BY item_name""")
        fun selectStockWithItems(): List<StockWithItemRec>
      }

      data class ItemStockRec(
        val itemName: String,
        val amount: BigDecimal,
        val serial: Int
      )

      data class StockWithItemRec(
        val itemName: String,
        val serial: Int,
        val manufacturersCode: String?,
        val unitCode: String,
        val unitName: String,
        val amount: BigDecimal
      )
					</script></code></pre>
    </section>
    <section>
      <pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|3-11|5|6|7|8-10|27|30-31|33-36|37-40"><script type="text/template">
      class ItemStockJdbiRepository(private val db: Jdbi) : ItemStockRepository {

        override fun findByItemId(itemId: ItemId): ItemStock =
          db.withHandle<ItemStock, RuntimeException> { handle ->
            val dao = handle.attach(ItemStockDao::class.java)
            val itemStock = dao.selectStockAmount(itemId.asAppId())
              ?: ItemStockRec(itemId.asAppId().id, BigDecimal.ZERO, 0)
            return@withHandle ItemStock(
              id = ItemStockAppId(itemId.asAppId(), itemStock.serial),
              amount = itemStock.amount)
        }

        override fun findByItemIds(itemIds: List<ItemId>): List<ItemStock> =
          db.withHandle<List<ItemStock>, RuntimeException> { handle ->
            val dao = handle.attach(ItemStockDao::class.java)
            val result = dao.selectStockAmounts(itemIds.map { itemId -> itemId.asAppId().id }.toTypedArray())
            return@withHandle result.map { rec ->
              ItemStock(
                  id = ItemStockAppId(
                      ItemAppId(rec.itemName),
                      rec.serial
                  ), amount = rec.amount
              )
            }
          }

        override fun update(itemStock: MutableItemStock) = db.useTransaction<RuntimeException> { handle ->
          val dao = handle.attach(ItemStockDao::class.java)
          itemStock.consume { command: MutatingCommand<ItemStock>, itemStockAppId: ItemStockAppId? ->
            // we use it to increment serial (optimistic lock)
            val id = itemStockAppId ?: command.base.id.asAppId()
            when (command) {
              is ReplenishCommand -> {
                dao.insertItemStock(command.base.id.asAppId(), command.amount)
                id.copy(serial = id.serial + 1)
              }
              is DeductCommand -> {
                dao.insertItemStock(command.base.id.asAppId(), -command.amount)
                id.copy(serial = id.serial + 1)
              }
            else -> throw InvalidDataException("Unsupported command ${command.javaClass.name}.")
            }
          }
        }
      }
      </script></code></pre>
    </section>

    <!-- ----------------------------------------
                   Summary and Q&A
    ----------------------------------------- -->
    <section>
      <p>Link to repo</p>
      <p>Link to slides</p>
    </section>
  </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        width: 1200,
        hash: true,
        navigationMode: 'linear',
        slideNumber: 'c/t',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
